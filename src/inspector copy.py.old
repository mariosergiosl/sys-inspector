#!/usr/bin/python3
# -*- coding: utf-8 -*-
# FILE: src/inspector.py
# VERSION: 0.19.0 (Full Documentation & Quality)

"""
Sys-Inspector Core Module.

This is the main entry point for the application. It coordinates:
1. eBPF Probes (C source compilation and Kernel injection).
2. Static System Inventory collection (via sys_info module).
3. Real-time Event Capture (via perf_buffer).
4. HTML Report Generation.
"""

import sys
import os
import argparse
import time
import socket
import struct
import pwd
import hashlib
import glob
import traceback
from bcc import BPF

sys.path.append('src')
try:
    from sys_inspector.bpf_programs import BPF_SOURCE
    from sys_inspector import sys_info
    from sys_inspector import report_generator
except ImportError as err:
    sys.exit(f"Error importing modules: {err}")

PROGRAM_VERSION = "0.19.0"
_USER_CACHE = {}
CLK_TCK = os.sysconf(os.sysconf_names['SC_CLK_TCK'])
b = None  # Global BPF object reference


# --- HELPERS ---
def get_username(uid):
    """
    Resolves User ID to Username with caching to minimize syscalls.

    Args:
        uid (int): User ID.

    Returns:
        str: Username or string representation of UID.
    """
    if uid not in _USER_CACHE:
        try:
            _USER_CACHE[uid] = pwd.getpwuid(uid).pw_name
        except Exception:
            _USER_CACHE[uid] = str(uid)
    return _USER_CACHE[uid]


def calculate_md5(filepath):
    """
    Calculates MD5 hash of a file safely.
    Used for forensic verification of binaries.

    Args:
        filepath (str): Path to the file.

    Returns:
        str: Hex digest of the MD5 hash or error message.
    """
    if not os.path.exists(filepath):
        return "N/A"
    try:
        hasher = hashlib.md5()
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hasher.update(chunk)
        return hasher.hexdigest()
    except Exception:
        return "ACCESS_DENIED"


def get_security_context(pid):
    """
    Reads the current security context (AppArmor/SELinux) of a process.

    Args:
        pid (int): Process ID.

    Returns:
        str: Security context label.
    """
    try:
        with open(f"/proc/{pid}/attr/current", "r", encoding="utf-8") as f:
            return f.read().strip().replace('\0', ' ')
    except Exception:
        return "unconfined"


def get_suspicious_env(pid):
    """
    Scans process environment variables for suspicious entries.
    Detects LD_PRELOAD, LD_LIBRARY_PATH, and PATH modifications pointing to /tmp.

    Args:
        pid (int): Process ID.

    Returns:
        list: List of suspicious environment strings.
    """
    suspicious = []
    try:
        with open(f"/proc/{pid}/environ", "rb") as f:
            env_data = f.read().decode('utf-8', 'replace').split('\0')
        for env_var in env_data:
            key = env_var.split('=')[0]
            if key in ["LD_PRELOAD", "LD_LIBRARY_PATH"]:
                suspicious.append(env_var)
            if key == "PATH" and "/tmp" in env_var:
                suspicious.append("PATH_IN_TMP")
    except Exception:
        pass
    return suspicious


def get_process_context(pid):
    """
    Retrieves execution context (SSH origin, Sudo user, Multiplexers).

    Args:
        pid (int): Process ID.

    Returns:
        str: Formatted string with context tags.
    """
    tags = []
    try:
        with open(f"/proc/{pid}/environ", "rb") as f:
            env = dict(i.split("=", 1) for i in f.read().decode('utf-8', 'replace').split('\0') if "=" in i)
        if 'SSH_CONNECTION' in env:
            tags.append(f"[SSH:{env['SSH_CONNECTION'].split()[0]}]")
        if 'SUDO_USER' in env:
            tags.append(f"[SUDO:{env['SUDO_USER']}]")
        if 'TMUX' in env:
            tags.append("[TMUX]")
    except Exception:
        pass
    return " ".join(tags)


def get_lifetime_io(pid):
    """
    Reads lifetime I/O stats from /proc/pid/io.
    This provides total bytes read/written since process start.

    Args:
        pid (int): Process ID.

    Returns:
        tuple: (read_bytes, write_bytes)
    """
    r_bytes, w_bytes = 0, 0
    try:
        with open(f"/proc/{pid}/io", "r", encoding="utf-8") as f:
            for line in f:
                if line.startswith("rchar:"):
                    r_bytes = int(line.split()[1])
                elif line.startswith("wchar:"):
                    w_bytes = int(line.split()[1])
    except Exception:
        pass
    return r_bytes, w_bytes


def get_cpu_ticks(pid):
    """
    Reads CPU ticks (utime + stime) from /proc/pid/stat.

    Args:
        pid (int): Process ID.

    Returns:
        int: Total ticks.
    """
    try:
        with open(f"/proc/{pid}/stat", "r", encoding="utf-8") as f:
            parts = f.read().split()
            return int(parts[13]) + int(parts[14])
    except Exception:
        return 0


def get_libraries(pid):
    """
    Scans /proc/pid/maps for loaded shared libraries (.so).

    Args:
        pid (int): Process ID.

    Returns:
        list: List of library paths.
    """
    libs = set()
    try:
        with open(f"/proc/{pid}/maps", "r", encoding="utf-8") as f:
            for line in f:
                if ".so" in line and "/" in line:
                    path = line.split()[-1]
                    if path.startswith("/"):
                        libs.add(path)
                    if len(libs) >= 50:
                        break
    except Exception:
        pass
    return list(libs)


def check_anomaly(node):
    """
    Performs heuristic anomaly detection on a process node.
    Assigns a score based on suspicious paths, deleted binaries, or tools.

    Args:
        node (ProcessNode): The process object to check.
    """
    score = 0
    if node.cmd.startswith(("/tmp", "/dev/shm")):
        score += 10
    if "(deleted)" in node.cmd:
        score += 5
    if any(x in node.cmd for x in ["nc ", "ncat", "socat"]):
        score += 5
    if node.suspicious_env:
        score += 5
    node.anomaly_score = score


# --- NODE CLASS ---
class ProcessNode:
    """
    Represents a captured process in the tree.
    Stores all metadata, metrics, and forensic artifacts.
    """
    # pylint: disable=too-few-public-methods, too-many-instance-attributes
    def __init__(self, pid, ppid, cmd, uid, prio=120):
        self.pid = pid
        self.ppid = ppid
        self.cmd = cmd
        self.uid = uid
        self.prio = prio
        self.vsz = 0
        self.rss = 0
        self.read_bytes_delta = 0
        self.write_bytes_delta = 0
        self.read_bytes_total = 0
        self.write_bytes_total = 0
        self.cpu_start_ticks = 0
        self.cpu_usage_pct = 0.0
        self.open_files = set()
        self.connections = set()
        self.is_new = False
        self.context = ""
        self.sec_ctx = "N/A"
        self.suspicious_env = []
        self.md5 = "Calculating..."
        self.anomaly_score = 0
        self.libs = []


process_tree = {}


def scan_proc(init_cpu=False):
    """
    Performs a static scan of /proc to populate the process tree
    with currently running processes before capturing events.
    """
    print("Scanning /proc...", end="\r")
    my_pid = os.getpid()
    for path in glob.glob('/proc/[0-9]*'):
        try:
            pid = int(os.path.basename(path))
            if pid == my_pid:
                continue

            with open(os.path.join(path, 'status'), "r", encoding="utf-8") as f:
                s = f.read()
            info = {line.split(':')[0]: line.split(':', 1)[1].strip() for line in s.splitlines() if ':' in line}

            if not init_cpu and pid in process_tree:
                process_tree[pid].rss = int(info.get('VmHWM', '0').replace('kB', '').strip()) * 1024
                continue

            try:
                with open(os.path.join(path, 'cmdline'), 'rb') as f:
                    cmd_bytes = f.read().replace(b'\0', b' ')
                    cmd = cmd_bytes.decode('utf-8', 'replace').strip() or info.get('Name', '?')
            except Exception:
                cmd = info.get('Name', '?')

            node = ProcessNode(pid, int(info.get('PPid', 0)), cmd, int(info.get('Uid', '0').split()[0]))
            if 'VmHWM' in info:
                node.rss = int(info.get('VmHWM', '0').replace('kB', '').strip()) * 1024

            node.cpu_start_ticks = get_cpu_ticks(pid)
            node.context = get_process_context(pid)
            node.sec_ctx = get_security_context(pid)
            node.suspicious_env = get_suspicious_env(pid)
            node.read_bytes_total, node.write_bytes_total = get_lifetime_io(pid)

            exe_link = os.path.realpath(os.path.join(path, 'exe'))
            if os.path.exists(exe_link):
                node.md5 = calculate_md5(exe_link)
            else:
                node.md5 = "N/A"

            node.libs = get_libraries(pid)
            check_anomaly(node)
            process_tree[pid] = node
        except Exception:
            continue
    print("Scanning /proc complete.              ")


def handle_event(_cpu, data, _size):
    """
    Callback function for eBPF events (perf_buffer).
    Decodes C structs and updates the ProcessNode.
    """
    # We access 'b' from module scope
    # pylint: disable=global-variable-not-assigned
    event = b["events"].event(data)
    pid = event.pid

    if pid not in process_tree:
        comm = event.comm.decode('utf-8', 'replace')
        process_tree[pid] = ProcessNode(pid, event.ppid, comm, event.uid, event.prio)
        process_tree[pid].is_new = True
        process_tree[pid].sec_ctx = get_security_context(pid)
        process_tree[pid].read_bytes_total, process_tree[pid].write_bytes_total = get_lifetime_io(pid)
        process_tree[pid].libs = get_libraries(pid)

    node = process_tree[pid]
    node.rss = max(node.rss, event.mem_peak_rss)

    t = event.type_id.decode('utf-8', 'replace')
    f = event.filename.decode('utf-8', 'replace')

    if t == 'E':
        node.cmd = f
        node.is_new = True
        node.md5 = calculate_md5(f)
        node.context = get_process_context(pid)
        check_anomaly(node)
    elif t == 'O':
        if not f.startswith(("/proc", "/sys", "/dev")):
            node.open_files.add(f)
    elif t == 'N':
        try:
            dst = socket.inet_ntop(socket.AF_INET, struct.pack("I", event.daddr))
            node.connections.add(f"IPv4 -> {dst}:{socket.ntohs(event.dport)}")
        except Exception:
            pass
    elif t == 'R':
        node.read_bytes_delta += event.io_bytes
    elif t == 'W':
        node.write_bytes_delta += event.io_bytes


def calculate_final_cpu(duration):
    """
    Calculates the CPU usage percentage for all processes
    based on the delta of CPU ticks over the capture duration.
    """
    print("Calculating CPU usage...")
    for pid, node in process_tree.items():
        end_ticks = get_cpu_ticks(pid)
        if end_ticks > 0 and node.cpu_start_ticks > 0:
            delta = end_ticks - node.cpu_start_ticks
            try:
                node.cpu_usage_pct = (delta / float(CLK_TCK)) / duration * 100.0
            except Exception:
                pass


def main():
    """
    Main entry point.
    Initializes eBPF, runs the capture loop, and triggers report generation.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("--html", help="HTML report file", required=True)
    parser.add_argument("-d", "--duration", type=int, default=10, help="Capture seconds")
    args = parser.parse_args()

    if os.geteuid() != 0:
        sys.exit("Error: Root required.")

    print(f"Loading sys-inspector v{PROGRAM_VERSION} (HTML Mode)...")
    print("Collecting system inventory...")
    inv = sys_info.collect_full_inventory()

    bpf_text = BPF_SOURCE.replace("00000", str(os.getpid()))
    global b
    try:
        b = BPF(text=bpf_text)
        b.attach_kprobe(event=b.get_syscall_fnname("execve"), fn_name="syscall__execve")
        b.attach_kprobe(event=b.get_syscall_fnname("openat"), fn_name="syscall__openat")
        b.attach_kprobe(event="tcp_v4_connect", fn_name="kprobe__tcp_v4_connect")
        b.attach_kretprobe(event="vfs_read", fn_name="kretprobe__vfs_read")
        b.attach_kretprobe(event="vfs_write", fn_name="kretprobe__vfs_write")
    except Exception as err:
        sys.exit(f"BPF Error: {err}")

    scan_proc(init_cpu=True)
    print(f"Capturing activity for {args.duration}s (Please wait)...")
    b["events"].open_perf_buffer(handle_event)
    s = time.time()
    try:
        while time.time() - s < args.duration:
            b.perf_buffer_poll(100)
    except KeyboardInterrupt:
        pass

    calculate_final_cpu(args.duration)

    print("Generating HTML Report...")
    try:
        out = report_generator.generate_html(inv, process_tree, args.html, PROGRAM_VERSION)
        print(f"\nSUCCESS: Report generated at: {os.path.abspath(out)}")
    except Exception as err:
        traceback.print_exc()
        print(f"Error generating HTML: {err}")


if __name__ == "__main__":
    main()
